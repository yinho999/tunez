defmodule TunezWeb.Artists.ShowLive do
  # PHOENIX LIVEVIEW WITH ASH INTEGRATION
  # =======================================
  # This LiveView displays detailed artist information and their albums
  # It demonstrates Ash's code interface functions and relationship loading

  alias Tunez.Music, warn: false
  use TunezWeb, :live_view

  require Logger

  # MOUNT CALLBACK
  # ==============
  # Initial LiveView setup - minimal initialization
  # The actual data loading happens in handle_params for better URL handling
  def mount(_params, _session, socket) do
    {:ok, socket}
  end

  # HANDLE_PARAMS CALLBACK
  # ======================
  # Called when URL parameters change (including initial page load)
  # This is where we fetch data using Ash's generated functions
  def handle_params(%{"id" => artist_id}, _url, socket) do
    # ASH INTEGRATION: Using generated function from domain
    # Music.get_artist_by_id! is generated by:
    #   define(:get_artist_by_id, action: :read, get_by: :id)
    #
    # The ! version raises on error (good for "not found" pages)
    # load: [:albums] uses Ash's relationship loading to fetch related data
    # This performs an efficient join/query to get all albums for this artist
    artist = Music.get_artist_by_id!(artist_id, load: [:albums])

    socket =
      socket
      |> assign(:artist, artist)
      |> assign(:page_title, artist.name)

    {:noreply, socket}
  end

  def render(assigns) do
    ~H"""
    <Layouts.app {assigns}>
      <.header>
        <.h1>
          {@artist.name}
        </.h1>
        <:action>
          <.button_link
            kind="error"
            inverse
            data-confirm={"Are you sure you want to delete #{@artist.name}?"}
            phx-click="destroy-artist"
          >
            Delete Artist
          </.button_link>
        </:action>
        <:action>
          <.button_link navigate={~p"/artists/#{@artist.id}/edit"} kind="primary" inverse>
            Edit Artist
          </.button_link>
        </:action>
      </.header>
      <div class="mb-6">{formatted(@artist.biography)}</div>

      <.button_link navigate={~p"/artists/#{@artist.id}/albums/new"} kind="primary">
        New Album
      </.button_link>

      <ul class="mt-10 space-y-6 md:space-y-10">
        <li :for={album <- @artist.albums}>
          <.album_details album={album} />
        </li>
      </ul>
    </Layouts.app>
    """
  end

  def album_details(assigns) do
    ~H"""
    <div id={"album-#{@album.id}"} class="md:flex gap-8 group">
      <div class="mx-auto mb-6 md:mb-0 w-2/3 md:w-72 lg:w-96">
        <.cover_image image={@album.cover_image_url} />
      </div>
      <div class="flex-1">
        <.header class="pl-3 pr-2 !m-0">
          <.h2>
            {@album.name} ({@album.year_released})
          </.h2>
          <:action>
            <.button_link
              size="sm"
              inverse
              kind="error"
              data-confirm={"Are you sure you want to delete #{@album.name}?"}
              phx-click="destroy-album"
              phx-value-id={@album.id}
            >
              Delete
            </.button_link>
          </:action>
          <:action>
            <.button_link size="sm" kind="primary" inverse navigate={~p"/albums/#{@album.id}/edit"}>
              Edit
            </.button_link>
          </:action>
        </.header>
        <.track_details tracks={[]} />
      </div>
    </div>
    """
  end

  defp track_details(assigns) do
    ~H"""
    <table :if={@tracks != []} class="w-full mt-2 -z-10">
      <tr :for={track <- @tracks} class="border-t first:border-0 border-gray-100">
        <th class="whitespace-nowrap w-1 p-3">
          {String.pad_leading("#{track.order}", 2, "0")}.
        </th>
        <td class="p-3">{track.name}</td>
        <td class="whitespace-nowrap w-1 text-right p-2">{track.duration_seconds}</td>
      </tr>
    </table>
    <div :if={@tracks == []} class="p-8 text-center italic text-gray-400">
      <.icon name="hero-clock" class="w-12 h-12 bg-base-300" /> Track data coming soon....
    </div>
    """
  end

  defp formatted(nil), do: ""

  defp formatted(text) when is_binary(text) do
    text
    |> String.split("\n", trim: false)
    |> Enum.intersperse(Phoenix.HTML.raw({:safe, "<br/>"}))
  end

  def follow_toggle(assigns) do
    event =
      if assigns.on do
        JS.push("unfollow")
      else
        JS.push("follow")
        |> JS.transition("animate-spin")
      end

    assigns = assign(assigns, :event, event)

    ~H"""
    <span phx-click={@event} class="ml-3 inline-block">
      <.icon
        name={if @on, do: "hero-star-solid", else: "hero-star"}
        class="w-8 h-8 bg-yellow-400 -mt-1.5 cursor-pointer"
      />
    </span>
    """
  end

  # EVENT HANDLERS WITH ASH ACTIONS
  # ================================
  # These handlers demonstrate using Ash's generated destroy functions

  def handle_event("destroy-artist", _params, socket) do
    # ASH INTEGRATION: Using generated destroy function
    # Music.destroy_artist is generated by:
    #   define(:destroy_artist, action: :destroy)
    #
    # Accepts either an artist record or ID
    # Returns :ok on success or {:error, changeset} on failure
    # Ash handles foreign key constraints and cascading if configured
    case Music.destroy_artist(socket.assigns.artist) do
      :ok ->
        socket =
          socket |> put_flash(:info, "Artist deleted successfully") |> push_navigate(to: ~p"/")

        {:noreply, socket}

      {:error, error} ->
        # Error could be validation failure, constraint violation, or policy rejection
        Logger.error("Could not delete artist '#{socket.assigns.artist.id}': #{inspect(error)}")
        socket = socket |> put_flash(:error, "Could not delete artist")
        {:noreply, socket}
    end
  end

  def handle_event("destroy-album", _params, socket) do
    case Music.destroy_album(socket.assigns.album) do
      :ok ->
        socket =
          socket
          |> update(:artist, fn artist ->
            Map.update!(artist, :albums, fn albums ->
              Enum.reject(albums, &(&1.id == album_id))
            end)
          end)
          |> put_flash(:info, "Album deleted successfully")

        {:noreply, socket}

      {:error, error} ->
        Logger.error("Could not delete album '#{socket.assigns.album.id}': #{inspect(error)}")
        socket = socket |> put_flash(:error, "Could not delete album")
        {:noreply, socket}
    end
  end

  def handle_event("follow", _params, socket) do
    {:noreply, socket}
  end

  def handle_event("unfollow", _params, socket) do
    {:noreply, socket}
  end
end
